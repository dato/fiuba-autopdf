#! /bin/bash

set -u

cd "$AUTOPDF_HOME/${1-.}" || exit 1

STAMPFILE=".autopdf_stamp"
TARGETFILE=".autopdf_targets"
BITBUCKET_URL=$(git config --get remote.origin.url |
                sed -r 's#.*(bitbucket.org).(.+)#https://\1/\2/commits#')

OUT=`mktemp`
ERR=`mktemp`
trap "rm -f $OUT $ERR" EXIT

update_one() {
  : >"$OUT"
  : >"$ERR"

  make -k -C "$1" --no-print-directory || prepare_errors "$1" >>"$ERR"

  git ls-files --full-name --ignored --other --exclude='*.pdf' -- "$1" |
  while read local; do
    if [[ $local -ot $STAMPFILE ]]; then
      continue
    fi
    local new=""
    local path="$AUTOPDF_DRIVE_DIR/$local"
    local dir=$(dirname "$path")
    local file=$(basename "$path")

    skicka ls "$path" >/dev/null 2>&1 || new="Nuevo PDF"

    if [[ -n $new ]]; then
      skicka mkdir -p "$dir"
    fi
    local kind="${new:-PDF actualizado}"

    skicka upload "$local" "$path"

    local url=$(skicka -debug ls -ll "$path" 2>/dev/null |
        sed -rn 's#.*id:\s*(\S+).*#https://drive.google.com/file/d/\1/view#p')

    cat >>"$OUT" <<-ATTACHMENT
        , {
            "title": "$kind: $file",
            "title_link": "$url",
            "fallback": "$kind: $file",
            "fields": [
                $(get_details "${local}")
            ],
            "color": "good"
          }
	ATTACHMENT
  done

  if [[ ( -s $OUT || -s $ERR ) && -n ${AUTOPDF_WEBHOOK_URL-} ]]; then
    curl -sSLd @- "$AUTOPDF_WEBHOOK_URL" <<-JSON
        {
          "channel": "$2",
          "username": "${AUTOPDF_BOT_NAME:-autopdf}",
          "attachments": [ {}
              $(cat "$OUT" "$ERR")
          ]
        }
	JSON
  fi
}

skicka() {
    env HOME="$AUTOPDF_HOME" skicka "$@"
}

get_details() {
  # Primero comprobamos si hay un .md correspondiente
  if git ls-files --error-unmatch -- "${1%.pdf}.md" >/dev/null 2>&1; then
    local path="${1%.pdf}.md"
  else
    # Si no, usamos eliminamos el nombre del archivo para hacer log del
    # directorio. El :// es para el caso en el que el archivo está en el
    # raíz.
    local path="://$1"
    path="${path%/*}"
  fi

  git log -1 -s --format='
    {"title": "Autor", "short": true, "value": "%aN"},
    {"title": "Revisión", "short": true, "value": "<'"$BITBUCKET_URL"'/%H|%h>"},
    {"title": "Log", "short": false, "value": "%s"}' -- "${path}"
}

prepare_errors() {
  make -k -C "$1" 2>&1 | gawk '
      /^pandoc / {
        inside = 1;
        match($0, / ([^ ]+.md)/, xs);
        s = "Error en " xs[1];
        printf(", { \"title\": \"%s\",         \
                    \"fallback\": \"%s\",      \
                    \"color\": \"danger\",     \
                    \"mrkdwn_in\": [\"text\"], \
                    \"text\": \"```",          \
               s, s);
        next;
      }

      inside {
        printf("%s\\n", $0);
      }

      /^pandoc:/ {
        inside = 0;
        print "```\"}"
      }'
}

main() {
  echo "Script starting at $(date +'%b %d, %H:%M:%S %Z')"

  if [ ! -e "$STAMPFILE" ]; then
    touch "$STAMPFILE"
  fi

  git fetch -q --prune
  git reset -q --hard "@{upstream}"

  if [[ ! -r $TARGETFILE ]]; then
      echo >&2 "'`pwd`/$TARGETFILE' does not exist"
  else
    while read subdir channel; do
      update_one "$subdir" "$channel"
    done <"$TARGETFILE"
  fi

  touch "$STAMPFILE"
  echo "Script finished at $(date +'%b %d, %H:%M:%S %Z')"
}

main
